<!doctype html>
<html lang="ko">
<head>
    <title>WEB-javascript by ha</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="ht_css_js-world.css">
    <!-- JQUERY 적용 -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
</head>

<body>
    <div id="header"></div>
    <aside>
        <ul>
            <li><a href="#var">변수</a></li>
            <li><a href="#expression">표현식과 문</a></li>
            <li><a href="#dataType">데이터 타입</a></li>
            <li><a href="#operator">연산자</a></li>
            <li><a href="#conditional">제어문</a></li>
            <li><a href="#function">함수</a></li>
            <li><a href="#array">배열</a></li>
            <li><a href="#string">String</a></li>
            <li><a href="#number">Number</a></li>
            <li><a href="#date">Date</a></li>
            <li><a href="#math">Math</a></li>
            <li><a href="#class">Class</a></li>
            <li><a href="#object">Object</a></li> 
            <li><a href="#object">Property</a></li>
            <li><a href="#object">Dom</a></li>
            <li><a href="#object">Bom</a></li>
            <li><a href="#evnet">Event</a></li>
        </ul>
    </aside>

    <div class="main spacing">
        <input id="night_day" type="button" value="night" onclick="
        alert('click!');
        if(document.querySelector('#night_day').value==='night'){
            document.querySelector('.main').style.backgroundColor='black';
            document.querySelector('body').style.backgroundColor='black';
            document.querySelector('body').style.color='ghostwhite';
            document.querySelector('#night_day').value='day';
        }else{
            document.querySelector('.main').style.backgroundColor='ghostwhite';
            document.querySelector('body').style.backgroundColor='rgba(226, 217, 243, 0.5)';
            document.querySelector('body').style.color='black';
            document.querySelector('#night_day').value='night';
        }">

    <h1> It's JavaScript</h1>
    <button onclick="
        if(document.querySelector('p').style.opacity=='0'){
            showDetail('p')
        }else{hideDetail('p')}
    ">자세히 보기</button>
        <p class="js_p">JavaScript is a programming language used to dynamically create web pages.<br>
        Early web pages are simple forms without interaction with users<br>
        All interactions are possible only through communication with the server<br>
        JavaScript는 1995년 Brendan Eich에 의해 발명되었으며 1997년 ECMA 표준이 되었습니다.
        </p>

    <article>
        <ol>
            <h2><li>async & defer</li></h2>
                <ul class="disc">
                    <li>script async src(async 스크립트 또는 비동기 스크립트)<br>
                        async 속성이 붙은 스크립트는 페이지와 완전히 독립적으로 동작한다.<br>
                        async 스크립트는 백그라운드에서 다운로드 되고 바로 실행된다. async 스크립트 샐힝중에는 HTML 파싱이 멈춘다.<br>
                        async는 크기가 작은 스크립트 먼저 다운되고 실행되기 때문에 정확한 순서를 예측할 수 없다.</li>
                    <li>script defer src<br>
                        브라우저는 defer 속성이 있는 스크립트를 HTML파싱을 멈추지 않고 '백그라운드'에서 다운로드를 한다.<br>
                        그리고 defer 스크립트의 실행은 페이지 구성(DOM)이 끝난 후 실행된다. DOM이 준비된 후에 실행되지만 DOMContentLoaded 이벤트 발생 전에 실행된다.<br>
                        defer 스크립트가 실행될 때는 순서대로 실행된다.(작은 스크립트가 먼저 다운되지만 실행은 순서대로)</li>
                </ul>
            <h2><li id="var">변수 Variable</li></h2>
                <ul class="disc">
                    <li><strong>undefined</strong>는 자바스크립트에서 제공하는 원시 타입의 값이다.</li>
                    <li>변수를 사용하려면 반드시 선언이 필요. 변수를 선언할 때는 var, let 키워드를 사용</li>
                    <li>var키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.<br>
                        만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다.<br>
                        이 값을 <strong>쓰레기 값(garbage value)</strong>라 한다.   </li>
                    <li>자바스크립트 엔진은 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을<br>
                        소스 코드에서 찾아내 먼저 실행한다.<br>
                        이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 <strong>변수 호이스팅(variable hoisting)</strong>이라 한다.<br>
                        사실 변수 선언뿐 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅 된다.</li>
                    <li>변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.</li>   
                    <li>값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 <strong>상수(constant)</strong>라 한다. const</li>
                    <li>가비지 콜렉터, 언매니지드 언어, 매니지드 언어</li>
                    <li>변수를 선언하면 데이터를 담을 수 있는 공간이 할당되고 변수가 공간을 가르킨다<br>
                        object는 데이터가 커서 데이터를 담을 수 있는 공간이 따로 할당되고 변수가 그 공간의 주소(reference)를 가르킨다.<br>
                        변수를 복제하면 데이터가 같이 복제되지만, object는 reference가 복제된다.<br>
                        const로 변수를 선언하면 값(reference)을 재할당할 수 없지만 object 데이터의 값은 변경할 수 있다.</li>
                </ul>

            <h2><li id="expression">표현식과 문</li></h2>
                <ul class="disc">
                    <li><strong>값</strong>은 식이 평가되어 생성된 결과를 말한다.</li>
                    <li><strong>리터럴</strong>은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.</li>
                    <li><strong>표현식</strong>은 값으로 평가될 수 있는 문이다. 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조한다.</li>
                    <li><strong>문</strong>은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.<br>
                        문은 여러 토큰으로 구성된다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.</li>
                    <li>세미콜론은 문의 종료를 나타낸다. </li>
                </ul>   
                
            <h2><li id="dataType">데이터 타입</li></h2>
                <ul class="disc">
                    <li><strong>숫자타입 number</strong> : 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재(NaN, Infinity)</li>
                    <li><strong>문자열타입 string</strong> : 문자열</li>
                    <li><strong>템플릿 리터럴</strong> : ES6부터 도입된 새로운 문자열 표기법으로 멀티라인 문자열, 표현식 삽입, 테그드 템플릿 등 편리한 문자열 처리기능 제공</li>
                    <li><strong>불리언타입 boolean</strong> : 논리적 참(true)과 거짓(false)</li>
                    <li><strong>undefined타입</strong> : var 키워드로 선언된 변수에 암묵적으로 할당되는 값</li>
                    <li><strong>null타입</strong> : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값</li>
                    <li><strong>심벌 타입 symbol</strong> : ES6에서 추가된 7번째 타입, 변경 불가능한 원시 타입의 값, 고유한 식별자가 필요할 때 사용(출력할 때는 .description을 붙여서 출력)</li>
                    <li>위의 데이터 타입 이외의 값은 모두 객체 타입, 자바스크립트는 객체 기반의 언어이며 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것이다.</li>
                    <li>javascript는 Dynamic typing : dynamically typed language</li>
                </ul>

            <h2><li id="operator">연산자</li></h2>
                <ul class="disc">
                    <li><strong>산술 연산자</strong>{+  -  *  **  /  %  ++  --}</li>
                    <li><strong>할당 연산자</strong>{=  +=  -=  *=  /=  %=}</li>
                    <li><strong>비교 연산자</strong>{==  ===  !=  !==  >  <  >=  <=}<br>
                        ==는 값만 비교(loose equality), ===는 값과 유형을 비교(strict equality)</li>
                    <li><strong>논리 연산자</strong>{&&(and)  ||(or)  !(not)}</li>
                    <li><strong>비트 연산자</strong>: 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산을 수행<br>
                        비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때도 사용{&  |  ^  ~  <<  >>  >>>}</li>
                    <li><strong>유형 연산자</strong>{typeof  instanceof}</li>
                    <li><h4>typeof</h4></li>
                        <ul>
                            <li>JavaScript에는 값을 포함할 수 있는 5가지 다른 데이터 유형이 있다.<br>
                                - string, number, boolean, object, function</li>
                            <li>6가지 유형의 객체<br>
                                - Object, Date, Array, String, Number, Boolean</li>                                
                            <li>그리고 값을 포함할 수 없는 2가지 데이터 유형<br>
                                - null, undefined</li>                                
                        </ul>
                    <li><strong>삼항 연산자</strong>{표현식 ? 반환값1 : 반환값2} : (?) 앞의 표현식에 따라 결괏값이 참이면 반환값1 반환, 결괏값이 거짓이면 반환값2를 반환</li>
                </ul>

            <h2><li id="conditional">제어문(control flow statements)- Loop, conditional statements</li></h2>
                <ul class="disc">
                    <li>Loop</li>
                        <ol>
                            <li>for : 코드 블록을 여러번 반복</li>
                            <li>for/in : 객체의 속성을 통해 루프</li>
                            <li>for/of : 반복 가능한 객체의 값을 반복</li>
                            <li>while : 지정된 조건이 참인 동안 코드 블록을 반복</li>
                            <li>do/while : 코드 블록을 한번 실행한 다음 지정된 조건이 참인 동안 루프를 반복</li>
                        </ol>
                    <li>conditional statements</li>
                        <ol>
                            <li>if</li>
                            <li>if/else</li>
                            <li>if/ else if /else</li>
                            <li>switch/case/default</li>
                            <li>condition ? value1 : value2<br>
                                name === 'ha' ? 'yes' : 'no'</li>
                        </ol>
                    <li>기타 제어문</li>
                        <ol>
                            <li>label : 프로그램 내의 특정 영역을 식별할 수 있도록 해주는 식별자,<br>
                                label 문을 사용하면 continue 문과 break 문의 동작이 프로그램의 흐름을 특정 영역으로 이동시킬 수 있다.</li>
                            <li>continue : 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 표현식의 판단으로 넘어간다.</li>
                            <li>break :  루프 내에서 사용하여 해당 반복문을 완전히 종료시키고, 반복문 바로 다음에 위치한 실행문으로 프로그램의 흐름을 이동</li>
                        </ol>
                </ul>

            <h2><li id="function">함수</li></h2>
                <ul class="disc">
                    <li>함수(function)란 하나의 특별한 목적의 작업을 수행하도록 설계된 독립적인 블록을 의미, 함수 선언문은 표현식이 아닌 문이다.</li>
                    <li>함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성(호출) 시점이 다르다.</li>
                    <li>함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.<br>
                        함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다. </li>
                    <li>매개변수보다 인수가 더 많은 경우 초과된 인수는 무시된다.<br>
                        [es6] (...agrs) 인자는 배열 형태로 전달된다.</li>
                    <li>미리 정의된 전역 함수</li>
                        <ol>
                            <li>eval() : 문자열로 표현된 자바스크립트 코드를 실행하는 함수</li>
                            <li>isFinite() : 전달된 값이 숫자(유한한 수)인지를 검사하여 그 결과를 반환</li>
                            <li>isNaN() : 전달된 값이 NaN(숫자가 아닌)인지를 검사하여 그 결과를 반환<br>
                                이 함수는 숫자로의 강제 변환에 따라 예상치 못한 결과를 얻을 수 있으므로 ECMA6부터는 Number.isNaN() 메소드의 사용을 권장</li>
                            <li>parseFloat(), parseInt() : 문자열을 파싱하여 부동 소수점 수(floating point number), 정수로 반환</li>
                            <li>decodeURI(), decodeURIComponent() : decodeURI() 함수는 encodeURI() 함수나 다른 방법으로 만들어진 URI를 해독,<br>
                                decodeURIComponent() 함수는 encodeURIComponent() 함수나 다른 방법으로 만들어진 URI 컴포넌트를 해독</li>
                            <li>encodeURI(), encodeURIComponent() : encodeURI() 함수는 URI에서 주소를 표시하는 특수문자를 제외하고, 모든 문자를 이스케이프 시퀀스 처리하여 부호화,<br>
                                하지만 encodeURIComponent() 함수는 URI에서 encodeURI() 함수에서 부호화하지 않은 모든 문자까지 포함하여 이스케이프 시퀀스 처리</li>
                            <li>escape(), unescape() : escape() 함수는 전달받은 문자열에서 특정 문자들을 16진법 이스케이프 시퀀스 문자로 변환,<br>
                                unescape() 함수는 전달받은 문자열에서 escape() 함수나 다른 방법으로 만들어진 16진법 이스케이프 시퀀스 문자를 원래의 문자로 변환</li>
                            <li>Number(), String()</li>
                            <li>Escape Sequence(이스케이프 시퀀스) : 프로그래밍 언어 특성상 표현할 수 없는 기능과 문자를 표현, 컴퓨터를 제어하는 목적으로 사용되는 특수한 문자</li>
                        </ol>
                    <li><strong>Arrow Function</strong><br>
                        const simpleArrow = () => console.log('simpleArrow')
                    </li>
                    <li>
                        IIFE : Immediately Invoked Function Expression - 함수가 바로 실행된다.<br>
                        function hello(){
                            console.log('IIFE')
                        }();
                    </li>
                </ul>

            <h2><li id="array">Array</li></h2>
                <ul class="disc">
                    <li>new Arry(), []</li>
                    <li><strong>Array.forEach((content, index, array)=>{})</strong>는 각 배열 요소에 대해 한 번씩 함수를 호출</li>

                    <li>push() : 배열의 뒤에 요소 추가, pop() : 배열의 뒤 요소 제거<br>
                        unshift() : 배열의 앞에 요소 추가, shift() : 배열의 앞 요소 제거<br>
                        join() : 배열의 모든 요소를 연결해 하나의 문자열로 만든다<br>
                        split() : String 객체를 지정한 구분자를 이용하여 여러 개의 문자열로 나눈다<br>
                        delete, concat() : 배열 합침</li>
                    <li>splice()는 배열의 기존 요소 제거(제거 후 추가도 가능), slice()는 배열에서 일부만 잘라내어 새로운 문자열 반환<br>
                        sort()는 배열을 알파벳순으로 정렬<br>
                        reverse()는 배열의 요소를 뒤집는다, 내림차순으로 배열을 정렬하는데 사용</li>    
                    <li>length속성을 사용하여 새 요소를 배열에 추가할 수도 있습니다, 인덱스가 높은 요소를 추가하면 배열에 정의되지 않은 "구멍"이 생길 수 있다.</li>
                    <li><strong>find()</strong>는 테스트 함수를 통과하는 첫 번째 배열 요소의 값을 반환<br>
                        <strong>filter()</strong>메서드는 테스트 함수를 통과한 모든 요소로 새 배열을 반환</li>
                    <li><strong>indexOf()</strong>는 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환, 배열안에 찾는 요소가 없으면 -1 반환<br>
                        lastIndexOf()지정된 요소가 마지막으로 발생한 위치를 반환, findIndex()는 테스트 함수를 통과하는 첫 번째 배열 요소의 인덱스를 반환<br>
                        <strong>Array.includes()</strong>는 요소가 배열에 있는지 확인(true,false)</li>
                    
                    <li>배열에서 가장 높은 숫자를 찾을 때 Math.max.apply(), 가장 낮은 숫자를 찾을 때 Math.min.apply()</li>
                    <li><strong>map()</strong>메서드는 각 배열 요소에 대해 함수를 수행하여 새 배열을 만든다.</li>
                    <li><strong>reduce()</strong>메서드는 각 배열 요소에서 함수를 실행하여 단일 값을 생성한다.<br>
                        reduceRight()메서드는 오른쪽에서 왼쪽으로 작동</li>
                    <li><strong>every()</strong>모든 배열 값이 테스트를 통과하는지 확인(true,false)<br>
                        <strong>some()</strong>일부 배열 값이 테스트를 통과하는지 확인(true,false)</li>

                    <li><strong>Array.from()</strong>는 길이 속성이 있는 개체 또는 반복 가능한 개체에서 Array개체를 반환</li>
                    <li><strong>Array.keys()</strong>는 배열 키가 있는 Array Iterator개체를 반환</li>
                    <li>const로 선언된 배열은 재할당할 수 없다, 배열의 요소는 변경할 수 있다.</li>
                    <li>const변수는 선언될 때 값을 할당해야 한다,const에는 블록 범위가 있다.</li>
                </ul>

            <h2><li id="set">Set과 Map</li></h2>
                <ul class="disc">
                    <li>set객체는 중복되지 않는 유일한 값들의 집합이다.</li>
                    <li>Set 객체의 요소 개수를 확인할 때는 Set.size를 사용</li>
                    <li>Set.add() : 요소 추가</li>
                    <li>===연산자는 NaN과 NaN을 다르다고 평가하지만 Set객체는 NaN과 NaN을 같다고 평가</li>
                    <li>Set.has()는 객체에 특정 요소가 존재하는지 확인하여 불리언 값을 반환</li>
                    <li>특정 요소를 삭제하려면 Set.delete를 사용, 모든 요소를 일괄 삭제하려면 Set.clear()사용</li>
                    <li>Set 객체의 요소를 순회하려면 Set.forEach()를 사용, 3개의 인수를 전달받는다.</li>
                    <li>교집합 : setA.intersection(setB), 합집합 : setA.union(setB), 차집합 : setA.difference(setB)</li>
                    <li>상위집합 확인 : setA.isSuperset(setB)</li>
                    <br>
                    <li>Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. Object를 키로 사용할 수 있다는 것은 Map의 중요한 기능입니다.</li>
                    <li>set()을 사용하여 맵에 요소를 추가하고 값을 변경할 수도 있다.</li>
                    <li>get()메서드는 Map의 키 값을 가져온다, size속성은 Map의 요소 수를 반환, delete()는 Map 요소를 제거, clear()메서드는 Map에서 모든 요소 제거,
                        키가 Map에 존재하는 has() 경우 true를 반환</li>
                    <li>지도는 객체로 typeof시 object반환</li>
                    <li>forEach()메서드는 Map의 각 키/값 쌍에 대한 함수를 호출, entries()는 Map에 [key, values]가 있는 반복자 객체를 반환,
                        Map.keys(), Map.values()
                    </li>
                </ul>

            <h2><li id="string">JavaScript String</li></h2>
                <ul class="disc">
                    <li>String Length</li>
                    <li>문자열 슬라이스 : slice(start, end), substring(start, end), substr(start, length)</li>
                    <li>replace()</li>
                    <li>대문자로 변환 : toUpperCase(), 소문자로 변환 : toLowerCase()</li>
                    <li>문자열 연결 : concat()</li>
                    <li>문자열의 양쪽에서 공백 제거 : trim()</li>
                    <li>문자열 패딩 : padStart(), padEnd()</li>
                    <li>문자열 문자 추출 : charAt() 문자열의 지정된 인덱스에 있는 문자를 반환, charCodeAt() 문자열의 지정된 인덱스에 있는 문자의 유니코드를 반환</li>
                    <li>문자열을 배열로 변환 : split()</li>
                    <li>문자열 검색 : indexOf(), lastIndexOf(), search()</li>
                    <li>문자열 일치 : match(), includes(), startsWith(), endsWith(), </li>
                    <li>template literals : 따옴표 대신 역따옴표를 사용하여 문자열 정의, 템플릿 리터럴은 여러 줄 문자열을 허용, Interpolation, 문자열에서 표현식 허용</li>
                </ul>
            
            <h2><li id="number">Number</li></h2>
                <ul class="disc">
                    <li>숫자가 아닌 문자열을 사용하여 산술을 수행하면 NaN(숫자가 아님)이 발생</li>
                    <li>isNaN()를 사용하여 값이 숫자가 아닌지 확인할 수 있다.</li>
                    <li>Infinity는 가능한 가장 큰 수 이외의 수를 계산하는 경우 자바스크립트가 반환하는 값이다.</li>
                    <li>0으로 나누기도 Infinity를 생성</li>
                    <li>자바스크립트는 숫자 상수 앞에 0x가 있으면 16진수로 해석한다.</li>
                    <li><strong>toString()</strong>메서드는 숫자를 문자열로 반환</li>
                    <li><strong>toExponential()</strong>메서드는 반올림되고 지수 표기법을 사용하여 작성된 숫자가 있는 문자열을 반환, 매개변수는 소수점 뒤의 문자 수를 정의</li>
                    <li><strong>toFixed()</strong>메서드는 지정된 소수 자릿수로 작성된 숫자와 함께 문자열을 반환</li>
                    <li><strong>toPrecision()</strong>메서드는 지정된 길이로 작성된 숫자와 함께 문자열을 반환</li>
                    <li><strong>valueOf()</strong>메서드는 숫자를 숫자로 반환</li>
                    <li>MAX_VALUE는 자바스크립트에서 가능한 가장 큰 수를 반환, 변수나 표현식 또는 값인 상태에서 .MAX_VALUE를 사용하면 undefined를 반환</li>
                    <li>MIN_VALUE는 자바스크립트에서 가능한 가장 낮은 수를 반환</li>
                    <li>POSITIVE_INFINITY 오버플로 시 반환</li>
                    <li>NEGATIVE_INFINITY 오버플로 시 반환</li>
                    <h4>변수를 숫자로 변환</h4>
                    <li><strong>Number()</strong>변수를 숫자로 변환하는데 사용, 날짜도 변환(1.1.1970 이후의 밀리초 수를 반환)</li>
                    <li><strong>parseInt()</strong>구문 분석 후 정수를 반환, 공백 허용, 첫 번째 숫자만 반환, 변환할 수 없는 경우 NaN가 반환</li>
                    <li><strong>parseFloat()</strong>구문 분석 후 숫자를 반환, 공백 허용, 첫 번째 숫자만 반환</li>
                </ul>

            <h2><li id="date">Date</li></h2>
                <ul class="disc">
                    <li>Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수다.</li>
                    <li>new Date()는 현재 날짜와 시간을 가지는 Date객체 반환</li>
                    <li>월은 생략할 수 없고, 매개변수를 하나만 제공하면 밀리초로 처리된다.</li>
                    <li>한 자리 및 두 자리 연도는 이전 세기(19xx)로 해석된다.</li>
                    <li>new Date(dateString)으로 새 날짜 개체를 만들 수 있다.</li> 
                    <li>자바스크립트는 1970년 1월 1일 00:00:00(UTC)이후의 날짜를 밀리초 단위로 저장한다.</li>
                    <li>자바스크립트는 기본적으로 날짜를 전체 텍스트 문자열 형식으로 출력, 날짜 개체를 HTML로 표시하면 toString()메서드를 사용하여 자동으로 문자열로 변환</li>
                    <li>자바스크립트 날짜 입력 형식에는 일반적으로 3가지 유형이 있다(ISO날짜,짧은 날짜, 긴 날짜)</li>
                    <li><strong>ISO Date</strong>"2015-03-25" (The International Standard)</li>
                    <li><strong>Short Date</strong>"03/25/2015"</li>
                    <li><strong>Long Date</strong>"Mar 25 2015" or "25 Mar 2015"</li>
                    <li>toUTCString()메서드는 날짜를 UTC문자열로 변환</li>
                    <li>toDateString()메서드는 날짜를 더 읽기 쉬운 형식으로 변환</li>
                    <li>toISOString()메서드는 ISO 표준 형식을 사용하여 Date 객체를 문자열로 변환</li>
                    <li>유효한 날짜 문자열이 있는 경우 Date.parse()메서드를 사용하여 밀리초로 변환</li>
                    <li>getFullYear(), getMonth(), getDate(), getHours(), getMinutes(), getSeconds(), getMilliseconds(), getTime(), getDay(), Date.now()</li>
                    <li>날짜 설정 방법 : setDate(), setFullYear(), setHours(), setMilliseconds(), setMinutes(), setMonth(), setSeconds(), setTime()</li>
                    <li>getTimezoneOffset()은 UTC와 Date 객체에 지정된 로캘 시간과의 차이를 분 단위로 반환</li>
                    <li>toLocaleString(), toLocaleTimeString()</li>
                </ul>

            <h2><li id="math">Math</li></h2>
                <ul class="disc">
                    <li>Math.PI, Math.abs, Math.round, Math.ceil, Math.floor, Math.sqrt, Math.random, Math.pow, Math.max, Math.min</li>
                </ul>

            <h2><li id="class">Class</li></h2>
                <ul class="disc">
                    <li>클래스는 새로운 객체 생성 메커니즘 / 클래스 몸체에서 정의할 수 있는 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드의 세가지가 있다.</li>
                    <li>클래스의 구문은 "엄격 모드"로 작성해야 한다, 변수를 선언하지 않고 사용하면 오류 발생</li>
                    <li>상속 : 클래스 상속을 생성하려면 extends 키워드를 사용한다, 클래스 상속으로 생성된 클래스는 다른 클래스의 모든 메서드를 상속한다.<br>
                        super()메서드는 부모 클래스를 참조, 부모의 속성과 메서드에 액세스한다.</li>
                    <li>클래스를 사용하면 getter와 setter도 사용할 수 있다, 클래스에 getter 및 setter를 추가하려면 get 및 set 키워드를 사용</li>
                    <li>Public & Private : publicField(외부에서 접근 가능) , #privateField(클래스 내부에서만 값을 읽고 변경가능)</li>
                    <li>Static : 오브젝트로 복제가 되지 않고 클래스 자체가 가진 보유한 값,메소드<br>
                        "prototype"이 아닌 클래스 함수 자체에 메서드를 설정할 수도 있습니다. 이런 메서드를 정적(static) 메서드라고 부른다,
                        정적 메서드는 메서드를 프로퍼티 형태로 직접 할당하는 것과 동일한 일을 한다.<br>
                        정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 주로 사용된다.
                    </li>
                    <li>클래스 선언은 호이스트되지 않는다, 클래스를 사용하려면 먼저 선언해야 한다.</li>
                    <li>instanceof : 왼쪽에 있는 오브젝트가 오른쪽에 있는 클래스를 이용해서 만들어졌는지 확인(true, false)<br>
                        aaa instanceof A</li>
                </ul>

            <h2><li id="object">Object</li></h2>
                <ul class="disc">
                    <li>JavaScript에서 거의 "모든 것"은 객체이다.</li>
                    <li>객체란 이름(name)과 값(value)으로 구성된 속성(property)의 정렬되지 않은 집합입니다.<br>
                        프로퍼티의 값으로 함수가 올 수도 있는데, 이러한 프로퍼티를 메소드(method)라고 합니다.</li>
                    <li>개체의 속성에 액세스하는 구문은 objectName.property 또는 objectName["property"] 또는 objectName[expression]</li>
                    <li>JavaScript 메소드는 함수 정의를 포함하는 속성으로 objectName.methodName()로 개체 메서드에 접근한다.</li>
                    <li>객체의 생성</li>
                        <ol>
                            <li>리터럴 표기(literal notation)<br>
                                var 객체이름 = {프로퍼티1이름 : 프로퍼티1의값, 프로퍼티2이름 : 프로퍼티2의값};</li>
                            <li>생성자 함수(constructor function)<br>
                                var day = new Date();, 사용자가 직접 객체 생성자 함수(object constructor function)를 작성하여 사용할 수도 있다.</li>
                            <li>Object.create() 메소드<br>
                                Object.create(프로토타입객체[, 새로운객체의프로퍼티1, 새로운객체의프로퍼티2, ...]);</li>
                        </ol>
                    <li>JavaScript에는 기본 객체에 대한 기본 제공 생성자가 있다.(Math는 전역 개체로 new를 사용x)<br>
                        new String(), new Number(), new Boolean(), new Array(), new RegExp(), new Function(), new Date()<br>
                        기본 데이터 유형의 객체 버전이 있지만 복잡한 객체를 만들 이유는 없다, 기본값이 훨씬 빠르다("", 50, true/false, {},[],/()/,())</li>

                    <li><h4>프로토타입(Prototype)</h4></li>
                        <ul>
                            <li>js는 프로토타입 기반(prototype-based)의 객체 지향 언어로 현재 존재하고 있는 객체를 프로토타입으로 사용하여,<br>
                                해당 객체를 복제하여 재사용하는 것을 상속이라고 합니다.</li>
                            <li>js의 모든 객체는 프로토타입이라는 객체를 가지고 있고, 모든 객체는 그들의 프로토타입으로부터 프로퍼티와 메소드를 상속받는다.</li>
                            <li>프로토타입 체인(prototype chain)</li>   
                                <ul type="circle">
                                    <li>js에서는 객체 이니셜라이저를 사용해 생성된 같은 타입의 객체들은 모두 같은 프로토타입을 가진다.</li>
                                    <li>new연산자를 사용해 생성한 객체는 생성자의 프로토타입을 자신의 프로토타입으로 상속받는다.</li>
                                    <li>Object.prototype 객체는 어떠한 프로토타입도 가지지 않으며, 아무런 프로퍼티도 상속받지 않는다.</li>
                                    <li>위와 같이 프로토타입이 상속되는 가상의 연결 고리를 프로토타입 체인(prototype chain)이라고 합니다.</li>
                                    <li>Object.prototype 객체는 이러한 프로토타입 체인에서도 가장 상위에 존재하는 프로토타입이다.<br>
                                        따라서 자바스크립트의 모든 객체는 Object.prototype 객체를 프로토타입으로 상속받습니다.</li>
                                </ul>
                            <li>프로토 타입을 생성하는 가장 기본적인 방법은 객체 생성자 함수(object constructor function)</li>
                            <li>생성자 함수를 작성하고 new 연산자를 사용해 객체를 생성하면, 같은 프로토타입을 가지는 객체들을 생성할 수 있다.</li>
                            <li>prototype 프로퍼티를 이용하면 현재 존재하고 있는 프로토타입에 새로운 프로퍼티나 메소드를 손쉽게 추가할 수 있다.</li>
                        </ul>
                    <li><h4>this</h4></li>
                        <ul>
                            <li>this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기참조 변수다.</li>
                            <li>this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.</li>
                            <li>JavaScript strict mode는 기본 바인딩을 허용하지 않는다.따라서 엄격모드에서 this는 undefined.</li>
                        </ul>
                </ul>
            
            <h2><li id="property">Property</li></h2>
                <ul class="disc">
                    <li>'Property'는 속성이란 뜻으로, JS에서는 객체 내부의 속성을 의미한다.</li>
                    <li>객체의 프로퍼티에 접근하는 방법은 2가지가 있다.</li>
                        <ol>
                            <li>대괄호[]로 접근</li>
                            <li>점 표기법을 이용한 접근</li>
                        </ol>
                    <li>프로퍼티는 총 6가지의 속성을 가지고 있다.</li>
                        <ol>
                            데이터 프로퍼티
                            <li>value : 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값이다.</li>
                            <li>writable : 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.</li>
                            <li>enumerable : 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다.</li>
                            <li>configurable : 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.</li>
                            접근자 프로퍼티
                            <li>get : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 떄 호출되는 접근자</li>
                            <li>set : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다.</li>
                        </ol>
                    <li>get&set은 객체의 속성값에 대한 접근 권한자 역할을 할 수 있다, get&set 자체로 writable의 역할을 가지고 있음</li>
                    <li>프로퍼티 안에 함수를 받는 프로퍼티를 일반적으로 메소드라고 한다.</li>
                    <li>프로퍼티는 object를 위해서 데이터를 저장, 메소드는 object가 요청 받을 수 있는 액션이다.</li>
                    <li>Object.defineProperties()메서드를 사용하면 여러 프로퍼티를 동시에 설정할 수 있다.</li>
                    <li>delete 키워드를 사용하여 객체의 프로퍼티를 삭제할 수 있다.<br>
                        - delete 객체이름.프로퍼티이름;</li>
                    <li>객체 메소드(method) : 모든 자바스크립트 객체는 Object 객체와 Object.prototype 객체의 모든 프로퍼티와 메소드를 상속받는다.<br>
                        자주 사용되는 대표적인 객체 메소드는 다음과 같습니다.</li>
                        <ol>
                            <li>hasOwnProperty() : 특정 프로퍼티가 해당 객체에 존재하는지를 검사</li>
                            <li>propertyIsEnumerable() : 메소드는 특정 프로퍼티가 해당 객체에 존재하고, 열거할 수 있는 프로퍼티인지를 검사<br>
                                열거할 수 있는 프로퍼티란 내부적으로 enumerable 플래그가 true로 설정된 프로퍼티를 의미<br>
                                이러한 프로퍼티들은 for / in 문으로 접근할 수 있게 됩니다.</li>
                            <li>isPrototypeOf()</li>
                            <li>isExtensible()</li>
                            <li>toString()</li>
                            <li>valueOf()</li>
                        </ol>
                </ul>

            <h2><li id="dom">DOM</li></h2>
                <ul class="disc">
                    <li>Document Object Model of the page문서 객체 모델<br>
                        HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 프로퍼티와 메서드를 제고하는 트리 자료 구조</li>
                    <li>브라우저는 HTML 코드를 해석해서 요소들을 트리 형태로 구조화해 표현하는 문서(데이터)를 생성,<br>
                        브라우저는 DOM을 통해 화면에 웹 콘텐츠들을 렌더링</li>
                    <li>렌더 트리는 오직 스크린에 그려지는 것으로 구성되어 있어 DOM과 다르다.<br>
                        (렌더링 되는 요소만 관련 있기 때문에 시각적으로 보이지 않는 요소는 제외된다.)</li>
                    <li>DOM은 가상 요소를 포함하지 않는다(ex. ::after)</li>
                    <li>DOM의 종류</li>
                        <ol>
                            <li>Core DOM : 모든 문서 타입을 위한 DOM 모델</li>
                            <li>HTML DOM : HTML 문서를 위한 DOM 모델</li>
                            <li>XML DOM : XML 문서를 위한 DOM 모델</li>
                        </ol>
                    <li>Document 객체 : 웹 페이지 그 자체를 의미, 웹 페이지에 존재하는 HTML 요소에 접근하고자 할 때는 반드시 Document 객체부터 시작</li>
                        Document 메소드
                            <ol>
                                <li><b>HTMl 요소 선택</b><br>
                                    document.getElementsByTagName(태그이름), document.getElementById(아이디),<br>
                                    document.getElementsByClassName(클래스이름), document.getElementsByName(name속성값), document.querySelectorAll(선택자)</li>
                                <li><b>HTML 요소 생성</b><br>
                                    document.createElement(HTML요소), document.write(텍스트)</li>
                                <li><b>HTML 이벤트 핸들러 추가</b><br>
                                    document.getElementById(아이디).onclick = function(){ 실행할 코드 }</li>
                                <li><b>HTML 객체의 선택</b><br>
                                    document.anchors, document.body, document.cookie, document.domain,<br>
                                    document.title, document.URL, document.doctype, document.documentElement.... </li>
                            </ol>
                    <li>HTML DOM을 이용하면 HTML 요소의 내용(content)이나 속성값, 스타일 등을 손쉽게 변경할 수 있다.<br>
                        HTML 요소의 내용을 변경하는 가장 쉬운 방법은 innerHTML 프로퍼티를 이용</li>
                    <li>HTML DOM은 노드(node)라고 불리는 계층적 단위에 정보를 저장. HTML DOM은 이러한 노드들을 정의하고, 그들 사이의 관계를 설명해 주는 역할(노드 트리)</li>
                    <li>노드의 종류 : 문서 노드, 요소 노드, 속성 노드, 텍스트 노드, 주석 노드</li>
                    <li>노드 트리의 가장 상위에는 단 하나의 루트 노드(root node)가 존재, 루트 노드를 제외한 모든 노드는 단 하나의 부모 노드(parent node)만을 가짐<br>
                        모든 요소 노드는 자식 노드(child node)를 가질 수 있고, 형제 노드(sibling node)란 같은 부모 노드를 가지는 모든 노드를 가리킨다.<br>
                        조상 노드(ancestor node)란 부모 노드를 포함해 계층적으로 현재 노드보다 상위에 존재하는 모든 노드, 자손 노드(descendant node)란 자식 노드를 포함해 계층적으로 현재 노드보다 하위에 존재하는 모든 노드</li>
                    <li>HTMl 문서에서 HTML DOM 노드에 접근하는 방법</li>
                        <ol>
                            <li>getElementsByTagName() : 특정 태그 이름을 가지는 모든 요소를 노드 리스트의 형태로 반환</li>
                            <li>노드 간의 관계를 이용하는 접근<br>
                                parentNode(부모 노드), childNodes(자식 노드 리스트), firstChild(첫 번째 자식 노드),<br>
                                lastChild(마지막 자식 노드), nextSibling(다음 형제 노드), previousSibling(이전 형제 노드)</li>
                        </ol>
                    <li>노드에 대한 정보</li>
                        <ul>
                            <li>nodeName : 노드 고유의 이름을 저장(해당 HTML 요소의 태그 이름을 대문자로 저장), 수정할 수 없는 읽기 전용 프로퍼티</li>
                            <li>nodeValue :  노드의 값을 저장</li>
                            <li>nodeType : 노드 고유의 타입을 저장하므로, 수정할 수 없는 읽기 전용 프로퍼티</li>
                        </ul>
                    <li>노드의 관리</li>
                        <ol>
                            <li>노드 추가 : appendChild(), insertBefore(), insertData()</li>
                            <li>노드 생성 : createElement(), createAttribute(), createTextNode()</li>
                            <li>노드 제거 : removeChild(), removeAttribute()</li>
                            <li>노드 복제 : cloneNode() 메소드를 사용하면 특정 노드를 복제할 수 있다.</li>
                            <li>노드의 값 변경 : nodeValue 프로퍼티를 사용하면 특정 노드의 값을 변경,<br>
                                setAttribute() 메소드는 속성 노드의 속성값을 변경,<br>
                                replaceChild() 메소드를 사용하면 기존의 요소 노드를 새로운 요소 노드로 교체,<br>
                                replaceData() 메소드를 사용하면 텍스트 노드의 텍스트 데이터를 바꿀 수 있다.</li>
                        </ol>
                </ul>
            <h2><li id="bom">BOM</li></h2>
                <ul class="disc">
                    <li>브라우저 객체 모델로 브라우저의 기능적인 요소들을 직접 제어하고 관리할 방법 제공<br>
                        DOM(Document Object Model) 으로 통합해서 칭하기도 한다.</li>
                    <li>Window 객체 : 웹 브라우저의 창(window)을 나타내는 객체로, 대부분의 웹 브라우저에서 지원하고 있다.<br>
                        - innerHeight, innerWidth 프로퍼티를 이용하여 브라우저의 창 크기 설정<br>
                        - open()메소드를 이용하면 새로운 브라우저 창을 열 수 있다, 세부적인 옵션들도 설정 가능<br>
                        - close()메소드를 이용하면 현재 브라우저나 특정 브라우저 창을 닫을 수 있다.</li>
                    <li>Location 객체 : 현재 브라우저에 표시된 HTML 문서의 주소를 얻거나, 브라우저에 새 문서를 불러올 때 사용할 수 있다.<br>
                        - href, hostname, pathname 프로퍼티<br>
                        - assign()메소드는 브라우저 창에 지정된 URL 주소에 존재하는 문서를 불러온다.<br>
                        - replace()메소드는 새 문서를 불러오기 전에, 현재 문서를 브라우저의 히스토리에서 제거한다는 점이 assign() 메소드와 다르다.<br>
                        - reload() 메소드는 브라우저 창에 현재 문서를 다시 불러온다.</li>
                    <li>History 객체 : 브라우저의 히스토리 정보를 문서와 문서 상태 목록으로 저장하는 객체, <br>
                        자바스크립트는 사용자의 개인 정보를 보호하기 위해 이 객체에 접근하는 방법을 일부 제한<br>
                        - length프로퍼티는 브라우저 히스토리 목록의 개수 반환<br>
                        - back(), forward()메소드는 브라우저의 뒤로가기 앞으로 가기<br>
                        - go()메소드를 이용하면 인수로 전달받는 정수만큼 히스토리 목록 사이를 이동할 수 있다.</li>
                    <li>Screen 객체 : 사용자의 디스플레이 화면에 대한 다양한 정보를 저장하는 객체<br>
                        - width, height 프로퍼티는 사용자의 디스플레이 화면크기를 픽셀 단위로 반환, availWidth, availHeight(실제 사용할 수 있는 화면의 크기)<br>
                        - colorDepth 프로퍼티는 사용자 화면에서 한 색상당 사용할 수 있는 비트 수를 반환<br>
                        (대부분의 컴퓨터는 24비트의 트루 컬러(true colors)나 30/36/48비트의 디프 컬러(deep colors)를 사용)<br>
                        - pixelDepth 프로퍼티는 사용자 화면에서 픽셀당 표시할 수 있는 비트 수를 반환</li>
                    <li>Navigator 객체 : 브라우저 공급자 및 버전 정보 등을 포함한 브라우저에 대한 다양한 정보를 저장하는 객체<br>
                        - 브라우저 스니핑 : 브라우저 간의 호환성을 유지하는 방법, navigator 객체는 브라우저 스니핑에서 사용할 수 있는 다양한 표준비표준 프로퍼티 제공<br>
                        - appName과 appCodeName 프로퍼티는 현재 사용하고 있는 브라우저의 전체 이름을 반환<br>
                        (브라우저 간 호환성을 위해 스니핑 코드로 대부분의 브라우저가 브라우저 이름을 "Netscape", 브러우저 코드명을 "Mozilla"로 사용<br>
                        - appVersion과 userAgent(상세 정보를 추가로 포함) 프로퍼티는 현재 사용하고 있는 브라우저의 버전 정보를 문자열로 반환<br>
                        - platform 프로퍼티는 현재 브라우저가 실행되고 있는 운영체제를 식별하는 문자열을 반환<br>
                        -  language 프로퍼티는 현재 사용 중인 브라우저의 기본 언어 설정을 반환<br>
                        - javaEnabled() 메소드는 현재 사용 중인 브라우저가 자바 애플릿을 실행할 수 있는지를 검사하는 비표준 메소드<br>
                        - cookieEnabled 프로퍼티는 현재 사용 중인 브라우저가 쿠키를 사용할 수 있는지를 검사하는 비표준 프로퍼티</li>
                    <li>대화 상자(dialog box) : alert(), confirm(), prompt()</li>
                    <li>타이머(timer) : setTimeout(), setInterval(), clearTimeout(), clearInterval()</li>
                </ul>

            <h2><li id="event">이벤트(event)</li></h2>
                <ul class="disc">
                    <li>이벤트란 웹브라우저가 알려주는 HTML 요소에 대한 사건의 발생을 의미, 웹페이지에 사용된 js는 발생한 이벤트에 반응하여 특정 동작을 수행</li>
                    <li>이벤트 리스너란 이벤트가 발생했을 떄 그 처리를 담당하는 함수를 가리키며, 이벤트 핸들러라고도 한다.<br>
                        지정된 타입의 이벤트가 특정 요소에서 발생하면, 웹 브라우저는 그 요소에 등록된 이벤트 리스너를 실행</li>
                    <li>이벤트 리스너 등록<br>
                        1. 객체나 요소에 프로퍼티로 등록 : js코드에서 프로퍼티로 등록, HTML태그에 속성으로 등록<br>
                        2. 객체나 요소의 메소드에 이벤트 리스너를 전달 :  addEventListener(), attachEvent(), removeEventListener()는 등록된 이벤트 리스너 삭제</li>
                    <li>이벤트 리스너 호출<br>
                        이벤트 리스너가 등록되고 해당 객체나 요소에 지정된 타입의 이벤트가 발생하면 브라우저는 자동으로 등록된 이벤트 리스너를 호출</li>
                    <li>이벤트 리스너는 인수로 이벤트 객체(event object)를 전달받으며, 식별자를 통해 전달받은 이벤트 객체를 참조</li>
                    <li>이벤트 객체는 해당 타입의 이벤트에 대한 상세 정보 저장, 모든 이벤트 객체는 type,target 프로퍼티를 가진다.</li>
                    <li>이벤트 전파 : 이벤트가 발생했을 때, 브라우저가 이벤트 리스너를 실행시킬 대상 요소를 결정하는 과정<br>
                        1. 버블링(bubbling) 전파 : 이벤트가 발생한 요소부터 시작해서, DOM 트리를 따라 위쪽으로 올라가며 전파되는 방식<br>
                        2. 캡쳐링(capturing) 전파 : 이벤트가 발생한 요소까지 DOM 트리의 최상위부터 아래쪽으로 내려가면 전파되는 방식<br>
                        (addEventListener() 메소드의 세 번째 인수에 true를 전달)</li>
                    <li>preventDefalult() 메소드나 returnValue 프로퍼티를 이용하면 기본 동작의 실행을 취소</li>
                    <li>stopPropagation() 메소드나 cancelBubble 프로퍼티를 이용하면 이벤트의 전파를 취소</li>
                </ul>

            <h2><li>Execute context</li></h2>
                <ul class="disc">
                    <li>JavaScript의 동작 원리를 담고 있는 핵심 개념으로<br>
                        자바스크립트가 스코프를 기반으로 식별자와 식별자에 바인딩된 값을 관리하는 방식과 호이스팅이 발생하는 이유, <br>
                        클로저의 동작 방식, 그리고 테스크 큐와 함께 동작하는 이벤트 핸들러와 비동기 처리의 동작 방식을 이해할 수 있다.</li>
                </ul>

            <h2><li>RegExp(Regular Expression)</li></h2>
                <ul class="disc">
                    <li>정규 표현식은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어다.</li>
                    <li>정규표현식은 문자열을 대상으로 패턴 매치 기능을 제공</li>
                    <li>/regexp/i : 정규 표현식 리터럴</li>
                    <li>RegExp 생성자 함수를 사용하여 RegExp 객체를 생성할 수도 있다.</li>
                    <li>exec()메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환</li>
                    <li>test()메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환</li>
                    <li>match()메서드는 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 모두 반환</li>
                    <li>패턴과 함께 정규 표현식을 구성하는 플래그는 정규 표현식의 검색 방식을 설정하기 위해 사용</li>
                    <li>플래그 flags</li>
                        <ul>
                            <li><strong>i</strong>(ignore case) : 대소문자를 구별하지 않고 패턴 검색</li>
                            <li><strong>g</strong>(Global) : 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색</li>
                            <li><strong>m</strong>(Multi line) : 문자열의 행이 바뀌더라도 패턴 검색을 계속한다.</li>
                            <li><strong>y</strong> : 대상 문자열의 현재 위치부터 비교를 시작하도록 설정</li>
                        </ul>
                </ul>

            <h2><li>에러 처리</li></h2>
                <ul class="disc">
                    <li>에러는 언제나 발생할 수 있다. 발생한 에러에 대해 대처하지 않고 방치하면 프로그램은 강제 종료된다.</li>
                    <li>try...catch문을 사용해 발생한 에러에 적절하게 대응하면 프로그램이 강제 종료되지 않고 계속해서 코드를 실행시킬 수 있다.</li>
                    <li>try...catch...finally, try...finally</li>
                    <li>Error 객체 : Error, SyntaxError, ReferenceError, TypeError, RangeError, URIError, EvalError</li>
                    <li>throw명령문을 사용하면 사용자 지정 오류를 생성할 수 있다.(throw 표현식;)</li>
                    <li><h4>Strict 모드</h4></li>
                        <ul>
                            <li>ECMAScript 5에서 처음으로 소개된 strict 모드는 자바스크립트 코드에 더욱 엄격한 오류 검사를 적용</li>
                            <li>strict 모드는 스크립트나 함수의 맨 처음에 "use strict" 지시어를 사용하여 선언</li>
                            <li>자바스크립트의 strict 모드는 기존 자바스크립트 언어의 일부 기능을 제한한 문법을 사용</li>
                            <li>몇 가지 중요한 기능을 수정하여 강력한 오류 검사와 함께 향상된 보안 기능을 제공</li>
                            <table>
                                <tr><th>변수</th><td>선언되지 않은 변수나 객체를 사용할 수 없음, eval() 함수 내에서 선언된 변수는 외부에서 사용할 수 없음.</td></tr>
                                <tr><th>프로퍼티</th><td>읽기 전용 프로퍼티에는 대입할 수 없음, 한 프로퍼티를 여러 번 정의할 수 없음.</td></tr>
                                <tr><th>함수</th><td>함수를 구문이나 블록 내에서 선언할 수 없음.</td></tr>
                                <tr><th>매개변수</th><td>매개변수의 이름이 중복되어서는 안됨, arguments 객체의 요소 값을 변경할 수 없음.</td></tr>
                                <tr><th>문자열</th><td>문자열 "eval"과 "arguments"는 사용할 수 없음.</td></tr>
                                <tr><th>8진수</th><td>숫자 리터럴에 8진수 값을 대입할 수 없음.</td></tr>
                                <tr><th>this</th><td>this 포인터가 가르키는 값이 null이나 undefined인 경우 전역 객체로 변환되지 않음.</td></tr>
                                <tr><th>delete</th><td>delete 키워드를 사용할 수 없음.</td></tr>
                                <tr><th>with</th><td>	with 문을 사용할 수 없음.</td></tr>
                                <tr><th>예약어</th><td>(implements, interface, let, package, private, protected, public, static, yield)예약어들은 사용할 수 없음.</td></tr>
                            </table>
                        </ul>
                </ul>

            <h2><li>JSON</li></h2>
                <ul class="disc">
                    <li>JSON : JavaScript Object Notation / AJAX : Asynchronous JavaScript And XML</li>
                    <li>key, value로 이루어진 데이터포맷, 데이터를 주고받을 때 쓸수 있는 가장 간단한 데이터포맷<br>
                        프로그래밍 언어와 플랫폼에 상관없이 사용가능</li>
                    <li>Object to JSON : JSON.stringfy(obj,)<br>
                        함수와 Symbol과 같은 자바스크립트에만 있는 데이터는 변환되지 않는다.</li>
                    <li>Json to Object : JSON.parse(json)</li>
                </ul>

            <h2><li>비동기처리 Asynchronous</li></h2>
                <ol>
                    <li>JavaScript is synchronous</li>
                    <li>
                        <h4>Callback</h4>
                        <ul>
                            <li>다른 함수의 인자로써 넘겨진 후 특정 이벤트에 의해 호출되는 함수</li>
                            <li>Synchronous callback, Asynchronous callback</li>
                            <li>setTimeout</li>
                        </ul>
                    </li>
                    <li>
                        <h4>Promise</h4>
                        <ul>
                            <li>JavaScript object for asynchronous operation</li>
                            <li>State : pending -> fulfilled or rejected</li>
                            <li>Producer vs Consumer</li>
                            <li>Producer<br>
                                const promise = new Promise((resolve, reject) => {
                                    resolve('a'); || reject(new Error('no'))
                                })<br>
                                when new Promise is created, the executor runs automatically.</li>
                            <li>
                                Consumer : then, catch, finally<br>
                                promise.then(value => {}) / then은 promise가 정상적으로 수행되어서 resolve함수를 통해서 전달한 값이 value의 파라미터로 전달되어져서 들어온다<br>
                                promise.catch(error ={}) / catch는 error가 발생했을 때 어떻게 처리할 건지<br>
                                promise.finally(()=>{}) / finally는 무조건 마지막으로 호출된다<br>
                                promise.then().catch().finally()
                            </li>
                            <li>Promise chaining<br>
                                promise.then(num => num*2).then(num => num*3).then(...)</li>
                            <li>Promise APIs<br>
                                promise.all() : 주어진 모든 프로미스가 이행하거나 한 프로미스가 거부될 때까지 대기하는 새로운 프로미스를 반환<br>
                                promise.race() : 주어진 모든 프로미스 중 하나라도 처리될 때까지 대기하는 프로미스를 반환</li>
                        </ul>
                    </li>
                    <li>
                        <h4>async & await</h4>
                        <ul>
                            <li>clear style of using promise</li>
                            <li>async<br>
                                async function(){}; -> async라는 키워드를 사용하면 promise로 바로 만들 수 있다.                                
                            </li>
                            <li>await<br>
                                async가 붙은 함수 안에서만 쓸 수 있다, 비동기로 처리되는 부분 앞에 붙여주면 된다.</li>
                        </ul>
                    </li>
                </ol>

            <h2><li>출처</li></h2>
                <ul class="disc">
                    <li><a href="http://www.tcpschool.com/" target="_blank">TCP SCHOOL</a></li>
                    <li><a href="https://www.w3schools.com/" target="_blank">W3SCHOOLS</a></li>
                    <li><a href="https://developer.mozilla.org/ko/" target="_blank">Mozilla</a></li>
                    <li>책 : </li>
                </ul>
        </ol>
    </article>     

        <input type="button" value="blue" onclick="
        if(this.value==='blue'){
            var target = document.querySelector('body');
            target.style.backgroundColor='blue';
            this.value='day';
            var alist = document.querySelectorAll('a');
            var i = 0;
            while(i < alist.length){
                alist[i].style.color = 'powderblue';
                i = i+1;
            }
        }else{
            var target = document.querySelector('body');
            target.style.backgroundColor='rgba(226, 217, 243, 0.5)';
            this.value='blue';
            var alist = document.querySelectorAll('a');
            var i = 0;
            while(i < alist.length){
                alist[i].style.color = 'blue';
                i = i+1;
            }
        }">
        <div>Hello Web : <span id="time"></span>일 경과</div>
        <button onclick="
                var newWin = window.open('index.html','','width=500,height=400');
                if (newWin == null){alert('팝업이 차단되어 있습니다. 팝업 차단 해체해주세요.')}
                newWin.moveBy(100,100);">팝업창</button>
        </div>

    <div id="footer"></div>
    <script type="text/javascript">
        $(function(){
            $("#header").load("./template/header.html");
            $("#footer").load("./template/footer.html");
        });

        function showDetail(tag){
            document.querySelector(tag).style.opacity = '1';
        }
        function hideDetail(tag){
            document.querySelector(tag).style.opacity = '0';
        }

        var now = new Date();
        var firstDay = new Date("2021-04-16");
        var toNow = now.getTime();
        var toFirst = firstDay.getTime();
        var passedTime = toNow - toFirst;

        passedTime = Math.round(passedTime/(1000*60*60*24));
        document.querySelector('#time').innerText = passedTime;
    </script>
    
</body>
</html>